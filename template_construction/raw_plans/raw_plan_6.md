# 阶段六：知识 / 能力 / Hook 的初始注册与脚手架验证规划

> 目标（一句话）：在前五个阶段打好的结构与工具基础上，**实际注册一批知识、能力和 Hook**，并通过这些真实案例，系统性验证阶段五的脚手架流程（AI + 人交互）的可用性与稳定性。

---

## 1. 阶段定位与范围

### 1.1 在整体路线中的位置

- 阶段一：目录骨架与空文件清单；  
- 阶段二：文档规范与 `AGENTS.md` 结构；  
- 阶段三：核心机制知识与标准流程说明；  
- 阶段四：注册写入脚本与协同校验接口；  
- 阶段五：脚手架知识文档 + orchestrator 脚本 + AI+人交互流程设计；  
- **阶段六：用真实的“知识 / 能力 / Hook 注册任务”去跑一遍脚手架，完成最小规模的“活体实验”**。

### 1.2 本阶段“做 / 不做”

**做：**

1. 在选定的几个领域内，实际注册一批知识文档（已由人提前准备），并确保：  
   - 能被脚手架流程正确发现和使用。  
2. 实际新增若干低级能力 / 高级能力（workflow/agent），完整跑通：  
   - AI 提案 → 人工确认 → 脚手架执行 → registry 写入 → workdocs 记录。  
3. 实际新增若干 Hook 注册条目，完整跑通同样的三段式流程。  
4. 在此过程中，有意识地“刻意测试”阶段五的脚手架工具：  
   - 至少每一类脚手架都跑通 1 次真实任务；  
   - 收集改进脚手架设计的反馈。  

**不做：**

- 不追求“覆盖所有能力 / 所有 Hook”，只做**代表性样本**；  
- 不在本阶段完善 DevOps 与 CI/CD 的真实集成（仍可只生成配置骨架）；  
- 不在本阶段大幅调整目录和规范（除非发现硬伤）。

---

## 2. 整体思路：三类对象 + 三段式流程

### 2.1 三类对象

1. **知识（Knowledge）**  
   - 典型载体：`knowledge/architecture/*.md`、`knowledge/modules/template/*.md`、`knowledge/devops/*.md`、`knowledge/scaffolding/*.md` 等；  
   - 本阶段：人提前写好或整理的大块知识，由 AI 协助“挂接到正确的位置”（AGENTS、路由、索引等）。  

2. **能力（Ability）**  
   - 低级能力（low-level）：由脚本 / 服务直接实现；  
   - 高级能力（high-level）：workflow / agent，组合低级能力和策略。  

3. **Hook 注册（Hook）**  
   - 仅限 `.system/hooks/*.yaml` 中的注册条目；  
   - 仍不实现具体 handler，重点是“挂上去”和与能力/路由的关系。  

### 2.2 三段式流程（特别适用于能力与 Hook）

统一采用：

> **「方案草案（AI） → 人工确认 / 修订 → 脚手架执行（AI+脚本）」**

具体：

1. **方案阶段（Planning）**  
   - AI 基于已有知识与需求，生成一份注册方案：  
     - 对能力：描述能力意图、输入输出、关联模块、预期调用路径；  
     - 对 Hook：描述 Hook 类型、绑定点、关联能力、预期作用。  
   - 方案以 `workdocs/active/<task_id>/plan.md` 或类似文件形式保存。  

2. **确认阶段（Review & Approval）**  
   - 人类阅读方案，提出修改 / 限制 / 补充；  
   - AI 根据反馈更新方案文档，并标记“已确认”。  

3. **执行阶段（Execution via Scaffolding）**  
   - AI 根据最终方案：  
     - 调用相应脚手架 orchestrator（`scripts/scaffold/*.py` 或 `PROJECT_INIT/scripts/*.py`）；   
     - 将结果回写到同一 `workdocs` 任务目录中（包括变更列表与后续 TODO）。  

**知识注册**相对简单，可以采用“二段式”：

> 人写内容 → AI 协助挂接（更新 AGENTS / 路由 / 索引），并在 workdocs 中记录。

---

## 3. 工作块 A：知识文档的注册与挂接

**目标：**把人准备好的知识文档“接上系统管道”，让 AGENTS / 路由 / 脚手架可以找到并使用它们。

### 3.1 任务 A1：知识文档选取与落点确认

由人完成：

1. 从现有文档库中选出本阶段要注册的知识文档样本（可以是：架构细化说明、模块模板说明、DevOps 模板、脚手架说明等）。  
2. 为每一份知识文档确定：  
   - 目标路径（`knowledge/...` 下具体位置）；  
   - 预期被哪些 `AGENTS.md` 或脚手架流程引用。  

### 3.2 任务 A2：AI 协助完成“挂接”

AI 在相应 scope 的 `AGENTS.md` 与相关配置中执行：


1. 若有需要（例如为脚手架提供知识索引），可在：  
   - `knowledge/architecture/overview.md` 或  
   - `knowledge/scaffolding/README.md`  
   中增加指向新文档的条目。  

2. 在相关 scope 的 `workdocs/` 中记录：  
   - 哪些知识文档在本阶段完成了注册 / 更新；  
 
**完成标志（A 块）：**

- 至少有一批（由你决定数量）知识文档已经完成：  
  - 放入 `knowledge/` 正确位置；  
  - 被相关 `AGENTS` 或脚手架说明引用。  

---

## 4. 工作块 B：能力（Ability）的实际注册与验证

**目标：**选择少量有代表性的能力，完整走一遍从方案 → 确认 → 注册的脚手架流程，并验证 Phase 4/5 的工具组合。

### 4.1 任务 B1：选择能力场景与类型

1. 给出几个备选的真实业务相关场景的低层/高层能力
2. 人工确认要选择哪几个
3. 对于每个场景，确定开发计划以及预期互动的基础设置/脚手架
 
### 4.2 任务 B2：AI 生成能力注册方案（Plan 阶段）

AI在`template_construction/`目录下创建方案文档，内容包括：

- 能力 ID、类型（low/high）、所属模块；  
- 能力的输入 / 输出约定；  
- 与现有能力的关系（复用 / 扩展 / 替代）；  
- 预期的调用路径（由哪个脚手架 / 路由 / Hook 使用）；  
- 对应的 registry 变更：  
  - `.system/registry/low-level/*.yaml` 或 `.system/registry/high-level/*.yaml` 中需要新增/修改的条目；  
- 需要新增/修改的模块内文件：  
  - `ABILITY.md` 中的条目；  
  - （如有）代码骨架文件路径。  

### 4.3 任务 B3：人工确认与修订（Review 阶段）

人类：

- 对能力方案做结构性评论，如：  
  - 能力边界是否合适；  
  - 是否拆得太细/太粗；  
  - 是否与模块职责一致；  
- 由 AI 根据评论对方案文档做修订，直至双方认可。  

### 4.4 任务 B4：脚手架执行与写入（Execution 阶段）

AI 根据最终方案：

1. 准备 orchestrator 需要的参数：  
   - ability_id、module_id、描述、输入输出结构等。  
2. 调用相应脚手架脚本，例如：  
   - `scripts/scaffold/new_ability_low.py` 或  
   - `scripts/scaffold/new_ability_high.py`。  
3. orchestrator 内部调用 Phase 4 的写入与校验函数，完成：  
   - 在 `.system/registry/low-level|high-level/*.yaml` 中新增能力条目；  
   - 在目标模块下创建/更新能力相关文件骨架（如需要）；  
   - 执行一致性校验（与模块注册、路由等）。  
4. 将脚本输出写入 `workdocs` 中，并给出总结：  
   - 实际变更的文件列表；  
   - 是否有 warning / TODO；  
   - 下一步建议。  

**完成标志（B 块）：**

- 至少有若干能力通过上述三段式流程完成注册；  
- 对每个能力，`workdocs` 中有完整记录，registry 与模块文件保持一致。  

---

## 5. 工作块 C：Hook 注册的实际演练

**目标：**基于已注册的能力，选取少量 hooks（如 PromptSubmit / PreAbilityCall / PostAbilityCall 等），走完方案 → 确认 → 注册的流程。

### 5.1 任务 C1：选择 Hook 场景与能力绑定

由人指定：

1. 哪些能力需要被 Hook 关注（例如：关键写操作能力、需要日志/审核的能力）；  
2. 希望在哪些阶段插入 Hook，例如：  
   - `PromptSubmit`：在用户提交任务前检查；  
   - `PreAbilityCall`：在能力执行前做额外验证；  
   - `PostAbilityCall`：在能力执行后记录结果或触发后续动作。  

### 5.2 任务 C2：AI 生成 Hook 注册方案（Plan 阶段）

AI 创建 Hook 方案文档，包含：

- Hook 类型（hook_type）；  
- 绑定的能力或能力集合；  
- 触发条件与频率（例如仅在某些 module/ability 上生效）；  
- 预期行为（高层描述：记录日志 / 标记风险 / 收集指标等）；  
- 对应的 registry 变更：  
  - `.system/hooks/<hook_type>.yaml` 中需要新增/修改的条目结构。  

### 5.3 任务 C3：人工确认与修订

人类：

- 对 Hook 的作用范围和风险进行判断：  
  - 是否太“激进”（影响所有能力）；  
  - 是否足够“可控”（容易禁用 / 调整）；  
- AI 根据反馈迭代方案。  

### 5.4 任务 C4：脚手架执行与写入

AI 根据确认后的方案：

1. 准备 orchestrator 参数；  
2. 调用 `scripts/scaffold/new_hook.py`：  
   - 内部调用 Phase 4 的 hook 注册写入脚本与一致性校验；  
   - 完成 `.system/hooks/<hook_type>.yaml` 的更新；  
3. 在 `workdocs` 中记录：  
   - 新增 Hook 条目的详细信息；  
   - 与哪些能力相关；  
   - 若未来需要 handler 实现，应去哪些目录（可以只写 TODO）。  

**完成标志（C 块）：**

- 至少有 1 个 Hook 成功注册，并与已有能力发生有效关联；  
- registry 与 `workdocs` 中的信息保持一致，有清晰的审计轨迹。  

---

## 6. 工作块 D：脚手架工具的验证与改进反馈

**目标：**通过上述实际任务，系统性验证阶段五设计的脚手架是否好用，并形成可执行的改进 TODO。

### 6.1 验证内容

- 是否能够在不手改 YAML 的前提下，完成注册操作；  
- 脚手架 orchestrator 的参数是否易于准备；  
- `AGENTS.md` 中的交互提示是否足够清晰；  
- `workdocs` 记录是否有助于事后追踪与复盘。  

### 6.2 反馈形式

- 可以在 `knowledge/scaffolding/README.md` 或单独的 `knowledge/scaffolding/improvement_notes.md` 中：  
  - 写下本阶段遇到的主要问题与思考；  
  - 列出下一阶段需要修改的脚手架/文档/脚本清单。  

---

## 8. 阶段六完成判定标准（Definition of Done）

当满足以下条件时，可认为 Phase 6 已完成：

1. 给定的知识文档已被：  
   - 放入 `knowledge/` 中合适的位置；  

2. 至少有若干低级能力与高级能力：  
   - 完整走过“方案 → 人工确认 → 脚手架执行”的流程；  
   - 完成了 registry 写入与必要骨架生成；  

3. 至少有一个 Hook 注册：  
   - 采用同样的三段式流程完成；  
   - 与已注册能力建立了清晰的关联。  

4. 所有上述操作均通过脚手架 orchestrator + 写入脚本完成，未发生手工直接改 YAML 的“救火式操作”（如果有，也需要在改进记录中说明原因）。  

5. 总结出一份脚手架使用反馈与改进建议，作为后续迭代的输入。  
